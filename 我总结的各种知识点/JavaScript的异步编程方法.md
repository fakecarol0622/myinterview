## JS的单线程机制

由于JS是单线程机制，任务的前后顺序是不能变的，在未执行完上一段代码时，不能做其他的事情，只能等待它执行完毕才能继续执行后面的代码。如果出现耗时较多的操作就会阻塞后面的代码。

为什么不设计成多线程呢？
因为JS是一门浏览器脚本语言，最开始只是为了处理一些表单验证和DOM操作被创造出来的，只能是单线程，否则会带来一些复杂的同步问题。例如在两个线程同时做增加和删除的操作，就无法处理。
为了充分利用CPU强大的计算能力，H5中提出了WebWorker的标准，允许JS创建多个子线程。但是子线程完全受主线程控制且无法操作DOM。

## 什么是异步
一个任务执行完后，会执行它的回调。而下一个任务不必等待这个任务结束就可以执行，等到上一个任务准备好之后才会执行这个回调。

## 异步是如何实现的
利用JS的**事件循环**（Event Loop）机制。
当JS执行时，会被分成同步和异步两类任务。同步任务会被放到栈里面按顺序执行，异步任务，当可以执行时，会被放到任务队列中等待执行。
当栈里的同步任务完成后，JS会去任务队列中查看是否有任务存在，并把这些任务放到栈中执行。执行完后会再次检查任务队列是否有新的可以执行的任务，这样循环检查的机制就是**事件循环**。

异步任务还可以被细分为**微任务**和**宏任务**。
**宏任务**：主代码块>setImmediate>setTimeout>setInterval
**微任务**：process.nextTick>promise
从任务队列中获取宏任务，执行第一个宏任务（主代码块）的过程中遇到微任务就加入微任务队列，然后执行完第一个宏任务马上执行完所有可执行的微任务，然后再取第二个宏任务执行...这样循环。
所以宏任务是一次循环只执行一个，微任务是一次性执行完。

## 异步编程方法

  **回调函数**
最早的异步处理方法。回调函数被传入另一个主体函数的参数中，在这个主体函数执行完以后执行。

  **事件监听**
异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

 **观察者模式**
当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知。比如事件绑定就是一个观察者模式。

 **Promise**
参见 [异步编程解决方案之Promise](https://blog.csdn.net/lixinyi0622/article/details/84589055)

 **Generator**
参见 [异步编程解决方案之Generator](https://blog.csdn.net/lixinyi0622/article/details/84589984)

 **async/await**
参见 [异步编程解决方案之async/await](https://blog.csdn.net/lixinyi0622/article/details/84568569)


